"""
Plotting Methods
================
"""

import numpy as np
import matplotlib as mpl

from mpl_plotter import figure
from mpl_plotter.color.schemes import colorscheme_one
from mpl_plotter.two_d import comparison, panes, line, scatter
from mpl_plotter.utils import span

from hopping_leg.plant.transforms import recordJS_to_TS
from hopping_leg.state_estimation.base_height import base_height_peaks


def plot_base_height(record,
                     h_desired=None,
                     plot_peaks=True,
                     h_peak_min=None,
                     show=True,
                     save=False,
                     filename=None):
    """
    Plots the height of the base of the hopping leg through a manoeuvre, including
    the desired and measured base height if provided, as well as the peaks of the
    estimated base height.

    **Arguments**

    ``record`` [``spine.data.record.record`` instance]
      experiment ``record`` object, containing the time vector of the
      experiment as well as the desired and measured state vectors
      of all motors in the experiment.

    ``h_desired`` [np.ndarray]
      desired height through a manouvre

    ``plot_peaks`` [bool]
      whether to plot the peaks found by ``hopping_leg.state_estimation.base_height.base_height_peaks``
      in the estimated base height array

    ``h_peak_min`` [float]
      minimum height for ``hopping_leg.state_estimation.base_height.base_height_peaks`` to identify a peak base height

    ``show`` [bool]
      whether to display the plot after calling this function. This is useful in case you wish to add
      more elements to the plot generated by this function

    ``save`` [bool]
      whether to save the plot generated by this function

    ``filename`` [str]
      name of the file to which the plot generated by this function will be saved
    """

    lne         = lambda *args, **kwargs: line(*args, **{**kwargs, **{'line_width': 1.25,
                                                                      'zorder':     2,
                                                                      'color':      '#d95959',
                                                                      'plot_label': '$est$'}})
    x           = [record.t] 
    curves      = [record.base_height_est]
    plotters    = [lne]
    
    if hasattr(record, 'base_height_msr'):

        lne         = lambda *args, **kwargs: line(*args, **{**kwargs, **{'line_width': 3,
                                                                          'zorder':     1,
                                                                          'color':      'black',
                                                                          'plot_label': '$msr$'}})
        x           = [record.t]               + x
        curves      = [record.base_height_msr] + curves
        plotters    = [lne]                    + plotters
        
    if h_desired is not None:

        lne         = lambda *args, **kwargs: line(*args, **{**kwargs, **{'line_width': 1.25,
                                                                          'zorder':     3,
                                                                          'color':      '#3fd487',
                                                                          'plot_label': '$des$'}})

        x           = [record.t]               + x
        curves      = [h_desired]              + curves
        plotters    = [lne]                    + plotters

    if plot_peaks:

        peaks_t, peaks_h = base_height_peaks(record.t,
                                             record.base_height_est,
                                             h_peak_min=h_peak_min if h_peak_min is not None else 0.3)

        sct = lambda *args, **kwargs: scatter(*args, **{**kwargs, **{'scatter_size':   20,
                                                                     'zorder':         4,
                                                                     'cmap':           'cool',
                                                                     'norm':           peaks_h,
                                                                     'plot_label':     '$peaks$'}})

        if peaks_t.shape != (0, ):
            x           += [peaks_t]
            curves      += [peaks_h]
            plotters    += [sct]
        else:
            plot_peaks = False
        
    comparison(x,
               curves,
               plotters,
               
               figsize=(12, 5),
               aspect=None,
               pad_demo=True,
               
               tick_label_decimals_x=1,
               tick_label_decimals_y=2,

               title='BASE HEIGHT',
               title_font='Latin Modern Mono',
               title_color='grey',
               title_size=15,
               title_pad=15,
               
               label_x='t [s]',
               label_y='h [m]',
               label_rotation_y=0,
               label_pad_y=20,
               
               # legend
               legend_loc=(0.89, 0.55),
               legend_size=11,
               legend=show,

               # layout
               top=0.895,
               bottom=0.17,
               left=0.115,
               right=0.870,
               hspace=0.35,
               wspace=0.6,

               show=False)
    
    from matplotlib import pyplot as plt

    if h_desired is not None and span(h_desired) == 0:
        
        plt.gcf().text(0.4425, 0.9, f'desired: {h_desired.mean():.2f} [m]',
                       color='#4a4a4a')
    
    if plot_peaks:

        from matplotlib.ticker import FormatStrFormatter
        
        prev_ax            = plt.gca()

        cb_coords          = [0.92, 0.17]
        cb_dimensions      = [0.01,  0.25]
        cb_ax              = plt.gcf().add_axes([*cb_coords, *cb_dimensions])
        cb_orientation     = 'vertical'

        cb_norm            = mpl.colors.Normalize(vmin=peaks_h.min(), vmax=peaks_h.max())
        cb_cmap            = 'cool'
        cb_mappable        = mpl.cm.ScalarMappable(norm=cb_norm, cmap=cb_cmap)

        cb_tick_locs       = None
        cb_tick_number     = 3
        cb_tick_decimals   = 2

        cb_title           = '$h_{peak}$ [m]'
        cb_top_title       = False
        cb_title_size      = 12
        cb_title_coords    = [-1.5, 1.135]
        cb_title_transform = 'transAxes'
        cb_title_pad       = 0.0

        # derived
        cb_tick_locs       = np.linspace(peaks_h.min(), peaks_h.max(), cb_tick_number) if cb_tick_locs is None else cb_tick_locs
        # -------
        
        cb = plt.colorbar(mappable    = cb_mappable,
                          cax         = cb_ax,
                          orientation = cb_orientation,
                          ticks       = cb_tick_locs)
        
        cb_ax.yaxis.set_major_formatter(FormatStrFormatter(f'%.{cb_tick_decimals}f'))
        
        if cb_top_title:
            cb_ax.set_title(label    = cb_title,
                            loc      = cb_loc,
                            pad      = cb_title_pad,
                            fontsize = cb_title_size)
        else:
            cb_ax.text(x          = cb_title_coords[0],
                       y          = cb_title_coords[1] * (1 + cb_title_pad),
                       s          = cb_title,
                       fontsize   = cb_title_size,
                       transform  = getattr(cb_ax, cb_title_transform))
        
        plt.sca(prev_ax)
        
    if save:

        assert filename is not None, 'you must provide a filename *without extension* to save the record plot of your experiment'
        
        plt.savefig(filename + '.eps', format='eps')
        plt.savefig(filename, dpi=200)
    
    if show:
        plt.show()
        plt.close()


        
def plot_foot_trajectory(plant,
                         record,
                         show=True,
                         save=False,
                         filename=None):
    """
    Plots the desired and measured foot trajectory in Cartesian space.

    **Arguments**

    ``plant`` [``hopping_leg.plant.plant.HopperPlant`` instance]
      hopping leg plant instance

    ``record`` [``spine.data.record.record`` instance]
      experiment ``record`` object, containing the time vector of the
      experiment as well as the desired and measured state vectors
      of all motors in the experiment.

    ``show`` [bool]
      whether to display the plot after calling this function. This is useful in case you wish to add
      more elements to the plot generated by this function

    ``save`` [bool]
      whether to save the plot generated by this function

    ``filename`` [str]
      name of the file to which the plot generated by this function will be saved
    """

    record = recordJS_to_TS(plant, record)

    # slice
    s = slice(1, -1)
    # array retrieval
    array  = lambda col: record[col].to_numpy()[s]
    
    base_height = array('base_height_msr') if hasattr(record, 'base_height_msr') else array('base_height_est')
    
    comparison([
                   array('y_des'),
                   array('y_msr')
               ],
               [
                   base_height - array('x_des'),
                   base_height - array('x_msr')
               ],
               
               figsize=(10, 5),
               aspect=None,
               pad_demo=True,
               
               tick_label_decimals_x=1,
               tick_label_decimals_y=2,

               title='BASE HEIGHT',
               title_font='Latin Modern Mono',
               title_color='grey',
               title_size=15,
               title_pad=15,
               
               label_x='t [s]',
               label_y='h [m]',
               label_rotation_y=0,
               label_pad_y=20,
               
               # curves
               line_widths=[3, 1.25],
               colors=['black', '#d95959'],

               # legend
               plot_labels=['$msr$', '$est$'],
               legend_loc=[0.89, 0.5],
               legend=show,

               # layout
               top=0.895,
               bottom=0.17,
               left=0.115,
               right=0.885,
               hspace=0.35,
               wspace=0.6,

               show=False)

    from matplotlib import pyplot as plt
    
    if save:

        assert filename is not None, 'you must provide a filename *without extension* to save the record plot of your experiment'
        
        plt.savefig(filename + '.eps', format='eps')
        plt.savefig(filename, dpi=200)
    
    if show:
        plt.show()
        plt.close()


        
def plot_task_space(plant,
                    record,
                    show=True,
                    save=False,
                    filename=None):
    """
    Plots the measured and desired task space state of the leg through a manouvre.

    **Arguments**

    ``plant`` [``hopping_leg.plant.plant.HopperPlant`` instance]
      hopping leg plant instance

    ``record`` [``spine.data.record.record`` instance]
      experiment ``record`` object, containing the time vector of the
      experiment as well as the desired and measured state vectors
      of all motors in the experiment.

    ``show`` [bool]
      whether to display the plot after calling this function. This is useful in case you wish to add
      more elements to the plot generated by this function

    ``save`` [bool]
      whether to save the plot generated by this function

    ``filename`` [str]
      name of the file to which the plot generated by this function will be saved
    """

    record = recordJS_to_TS(plant, record)

    # number of dimensions
    dimensions = ['x', 'y']
    m = len(dimensions)

    # variables
    variables = ['x', 'xd', 'xdd',
                 'y', 'yd', 'ydd']
    
    # slice
    s = slice(1, -1)

    # array retrieval
    array = lambda col: record[col].to_numpy()[s]

    
    x        = array('t')
    y        = []
    titles   = []
    y_labels = []

    for i in range(m):
        
        v = dimensions[i]
        
        y        += [[array(f'{v}_des'),   array(f'{v}_msr'),],
                     [array(f'{v}d_des'),  array(f'{v}d_msr'),],
                     [array(f'{v}dd_des'), array(f'{v}dd_msr'),]]
        
        titles   += [f'${v}$',     f'$\dot{v}$',       f'$\ddot{v}$']
        y_labels += ['$m$',    r'$\frac{m}{s}$',  r'$\frac{m}{s^2}$']
        
        
    colorscheme    = colorscheme_one()
    colorscheme[0] = '#d95959'

    shape = (2, 5)
        
    panes(x, y,

          shape=(2,5),
          figsize=(16.5, 3.5*m),

          tick_label_decimals_x=1,
          tick_label_decimals_y=2,
          
          titles=titles,
          label_x='t [s]',
          labels_y=y_labels,
          label_rotation_y=0,
          label_pad_y=10,

          # curves
          zorders=[2, 3],
          line_widths=[3, 1.25],
          colors=['black', '#d95959'],

          # legend
          plot_labels=['$des$', '$msr$'],
          legend_loc=[0.91, 0.45],
          legend=False,
          
          # layout
          rows=m,
          top=0.96,
          bottom=0.05,
          left=0.075,
          right=0.885,
          hspace=0.35,
          wspace=0.6)

    from matplotlib import pyplot as plt

    ax = plt.subplot2grid(shape,
                          (0, 3),
                          rowspan=2,
                          colspan=2)

    # max deviation in millimiters
    def maxdev(ax, scale=1000):
        dev = array(f'{ax}_des') - array(f'{ax}_msr')
        return dev[abs(dev).argmax()]*scale
    
    # horizontal axis mean
    tick_decimals_x = 0
    mean = lambda ax: f'{array(f"{ax}_des").mean():.{tick_decimals_x}f}'

    # horizontal axis settings if a constant Cartesian horizontal position was commanded
    if span(array('y_msr')) == 0:
        x_tick_args = {
            'tick_number_x':    3,
            'tick_labels_x':    ['', mean('y'), ''],
            'tick_locations_x': [array('y_msr').min(), array('y_des').mean(), array('y_msr').max()],
        }
    else:
        x_tick_args = {
            'tick_number_x':         5,
            'tick_label_decimals_x': 2
        }
    
    comparison([array('y_des'), array('y_msr')],
               [array('x_des'), array('x_msr')],
               zorders=[1, 2],
               
               title=f'FOOT TRAJECTORY | max devs: x[{maxdev("x"):.1f}] y[{maxdev("y"):.1f}] mm',
               title_font='Latin Modern Mono',
               title_color='grey',
               title_size=15,

               label_x='$y$ [m]',
               label_y='$x$ [m]', label_rotation_y=0, label_pad_y=20,
               colors=['black', '#d95959'],

               scale=1,
               aspect=1,

               # tick arguments
               **x_tick_args,
               tick_label_decimals_y=2,

               fig=plt.gcf(),
               ax=ax,

               legend=True,
               legend_loc=(0.92, 0.5),
               
               top=0.95,
               bottom=0.11,
               left=0.05,
               right=0.9,
               hspace=0.075,
               wspace=0.5)
    
    if save:

        assert filename is not None, 'you must provide a filename *without extension* to save the record plot of your experiment'
        
        plt.savefig(filename + '.eps', format='eps')
        plt.savefig(filename, dpi=200)

    if show:
        plt.show()
        plt.close()

